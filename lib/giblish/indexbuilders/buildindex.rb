# frozen_string_literal: true

require "pathname"
require "git"

require_relative "../pathtree"
require_relative "../gititf"
require_relative "verbatimtree"

module Giblish
  class IndexSrcFromTree
    attr_reader :adoc_source

    # The fixed heading of the table used to display file history
    HISTORY_TABLE_HEADING = <<~HISTORY_HEADER
      File history::
  
      [cols=\"2,3,8\",options=\"header\"]
      |===
      |Date |Author |Message
    HISTORY_HEADER

    # options:
    def initialize(src_tree)
      @adoc_source = <<~DOC_STR
        #{title}
        #{subtitle(src_tree)}
        #{header}

        #{generation_info}

        #{tree(src_tree)}

        #{document_details(src_tree)}

        #{footer}
      DOC_STR
    end

    protected

    def title
      "= Document index"
    end

    def subtitle(src_tree)
      "from #{src_tree.pathname}"
    end

    def header
      ":icons: font"
    end

    def generation_info
      "*Generated by Giblish at:* #{Time.now.strftime("%Y-%m-%d %H:%M")}"
    end

    def tree(src_tree)
      VerbatimTree.new(src_tree).source
    end

    def add_depgraph_id
      # include link to dependency graph if it exists
      <<~DEPGRAPH_STR
        _A visual graph of document dependencies can be found
        <<./graph.adoc#,here>>
      DEPGRAPH_STR
    end

    def document_details(src_tree)
      details_str = +"== Document details\n\n"

      src_tree.traverse_preorder do |_level, node|
        next unless node.leaf?

        d = node.data
        details_str << (d.converted ? document_detail(d) : document_detail_fail(d))
      end
      details_str
    end

    def footer
      ""
    end

    # return the adoc string for displaying the source file
    def display_source_file(doc_info)
      <<~SRC_FILE_TXT
        Source file::
        #{doc_info.src_file}
      SRC_FILE_TXT
    end

    private

    # return info about any conversion issues during the
    # asciidoctor conversion
    def conversion_issues(doc_info)
      return "" if doc_info.stderr.empty?

      # extract conversion warnings from asciddoctor std err
      conv_warnings = doc_info.stderr.gsub(/^/, " * ")

      # assemble info to index page
      <<~CONV_INFO
        Conversion issues::

        #{conv_warnings}
      CONV_INFO
    end

    def history_info(doc_info)
      return "" unless defined?(doc_info.history) && !doc_info.history.empty?

      str = +HISTORY_TABLE_HEADING

      # Generate table rows of history information
      doc_info.history.each do |h|
        str << <<~HISTORY_ROW
          |#{h.date.strftime("%Y-%m-%d")}
          |#{h.author}
          |#{h.message}
  
        HISTORY_ROW
      end
      str << "|===\n\n"
    end

    def document_detail_fail(doc_info)
      <<~FAIL_INFO
        === #{doc_info.src_file}

        #{display_source_file(doc_info)}

        Error detail::
        #{doc_info.stderr}

        ''''

      FAIL_INFO
    end

    # Show some details about file content
    def document_detail(doc_info)
      <<~DETAIL_SRC
        [[#{Giblish.to_valid_id(doc_info.title.encode("utf-8"))}]]
        === #{doc_info.title.encode("utf-8")}

        #{"Doc id::\n_#{doc_info.doc_id}_" unless doc_info.doc_id.nil?}

        #{"Purpose::\n#{doc_info.purpose_str}" unless doc_info.purpose_str.to_s.empty?}

        #{conversion_issues doc_info}

        #{display_source_file(doc_info)}

        #{history_info(doc_info)}

        '''

      DETAIL_SRC
    end
  end

  class IndexTreeBuilder
    attr_reader :adoc_source

    def initialize(dst_top_path, da_provider = nil, api_opt_provider = nil)
      @dst_top_path = dst_top_path
      @da_provider = da_provider
      @api_opt_provider = api_opt_provider
    end

    def document_attributes(src_node, dst_node, dst_top)
      @da_provider.nil? ? {} : @da_provider.document_attributes(src_node, dst_node, dst_top)
    end

    def api_options(src_node, dst_node, dst_top)
      @api_opt_provider.nil? ? {} : @api_opt_provider.api_options(dst_top)
    end

    # 1. Build a virtual source tree where each node is a dir
    # index
    # 2. Convert the virtual source tree to the same dst as the
    # adoc files.
    def run(src_tree, dst_tree, converter)
      dst_tree.traverse_preorder do |level, dst_node|
        # only care about dirs under dst_top_path
        next if dst_node.leaf? || (dst_node.pathname <=> @dst_top_path) == -1

        # get the relative path to the index dir from the top dir
        index_dir = dst_node.pathname.relative_path_from(@dst_top_path).cleanpath
        Giblog.logger.info { "Setting up index for #{index_dir}" }

        # add a virtual 'index.adoc' node with this object as source for conversion options
        # and adoc_source
        @adoc_source = IndexSrcFromTree.new(dst_node).adoc_source

        i_node = dst_node.add_descendants("index.adoc", self)

        # setup any additional doc attributes
        @da_provider.update_info(src_tree, dst_node, converter) unless @da_provider.nil?

        # update the provider of api options with this node's info
        @api_opt_provider.update_info(src_tree, dst_node, converter) unless @api_opt_provider.nil?

        # do the conversion
        converter.convert(i_node, i_node, dst_tree.node(@dst_top_path, from_root: true))
      end
    end
  end
end
