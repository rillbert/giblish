# frozen_string_literal: true

require "pathname"
require "git"

require_relative "../pathtree"
require_relative "../gititf"
require_relative "verbatimtree"

module Giblish
  class IndexSrcFromTree
    attr_reader :adoc_source

    # The fixed heading of the table used to display file history
    HISTORY_TABLE_HEADING = <<~HISTORY_HEADER
      File history::
  
      [cols=\"2,3,8\",options=\"header\"]
      |===
      |Date |Author |Message
    HISTORY_HEADER

    def initialize(src_tree)
      puts src_tree
      @adoc_source = <<~DOC_STR
        #{title}
        #{subtitle(src_tree)}
        #{header}

        #{generation_info}

        #{tree(src_tree)}

        #{document_details(src_tree)}

        #{footer}
      DOC_STR
    end

    protected

    def title
      "= Document index"
    end

    def subtitle(src_tree)
      "from #{src_tree.pathname}"
    end

    def header
      ":icons: font"
    end

    def generation_info
      "*Generated by Giblish at:* #{Time.now.strftime("%Y-%m-%d %H:%M")}"
    end

    def tree(src_tree)
      VerbatimTree.new(src_tree).source
    end

    def add_depgraph_id
      # include link to dependency graph if it exists
      <<~DEPGRAPH_STR
        _A visual graph of document dependencies can be found
        <<./graph.adoc#,here>>
      DEPGRAPH_STR
    end

    def document_details(src_tree)
      details_str = +"== Document details\n\n"

      src_tree.traverse_preorder do |_level, node|
        next unless node.leaf?

        d = node.data
        details_str << (d.converted ? document_detail(d) : document_detail_fail(d))
      end
      details_str
    end

    def footer
      ""
    end

    # return the adoc string for displaying the source file
    def display_source_file(doc_info)
      <<~SRC_FILE_TXT
        Source file::
        #{doc_info.src_file}
      SRC_FILE_TXT
    end

    private

    # return info about any conversion issues during the
    # asciidoctor conversion
    def conversion_issues(doc_info)
      return "" if doc_info.stderr.empty?

      # extract conversion warnings from asciddoctor std err
      conv_warnings = doc_info.stderr.gsub(/^/, " * ")

      # assemble info to index page
      <<~CONV_INFO
        Conversion issues::

        #{conv_warnings}
      CONV_INFO
    end

    def history_info(doc_info)
      return "" unless defined?(doc_info.history) && !doc_info.history.empty?

      str = +HISTORY_TABLE_HEADING

      # Generate table rows of history information
      doc_info.history.each do |h|
        str << <<~HISTORY_ROW
          |#{h.date.strftime("%Y-%m-%d")}
          |#{h.author}
          |#{h.message}
  
        HISTORY_ROW
      end
      str << "|===\n\n"
    end

    def document_detail_fail(doc_info)
      <<~FAIL_INFO
        === #{doc_info.src_file}

        #{display_source_file(doc_info)}

        Error detail::
        #{doc_info.stderr}

        ''''

      FAIL_INFO
    end

    # Show some details about file content
    def document_detail(doc_info)
      <<~DETAIL_SRC
        [[#{Giblish.to_valid_id(doc_info.title.encode("utf-8"))}]]
        === #{doc_info.title.encode("utf-8")}

        #{"Doc id::\n_#{doc_info.doc_id}_" unless doc_info.doc_id.nil?}

        #{"Purpose::\n#{doc_info.purpose_str}" unless doc_info.purpose_str.to_s.empty?}

        #{conversion_issues doc_info}

        #{display_source_file(doc_info)}

        #{history_info(doc_info)}

        '''

      DETAIL_SRC
    end
  end

  class IndexTreeBuilder
    attr_accessor :da_provider

    def initialize(da_provider = nil, api_opt_provider = nil)
      @da_provider = da_provider
      @api_opt_provider = api_opt_provider
      @adoc_source = nil
    end

    def document_attributes(src_node, dst_node, dst_top)
      @da_provider.nil? ? {} : @da_provider.document_attributes(src_node, dst_node, dst_top)
    end

    def api_options(src_node, dst_node, dst_top)
      @api_opt_provider.nil? ? {} : @api_opt_provider.api_options(dst_top)
    end

    def adoc_source(src_node, dst_node, dst_top)
      @adoc_source
    end

    # Called from TreeConverter during post build phase
    #
    # adds a 'index' node for each directory in the source tree
    # and convert that index using the options from the provider
    # objects given at instantiation of this object
    def run(src_tree, dst_tree, converter)
      dst_tree.traverse_preorder do |level, dst_node|
        next if dst_node.leaf?

        # get the relative path to the index dir from the top dir
        index_dir = dst_node.pathname.relative_path_from(dst_tree.pathname).cleanpath
        Giblog.logger.info { "Setting up index for #{index_dir}" }

        # build the index source for all nodes below dst_node
        @adoc_source= IndexSrcFromTree.new(dst_node).adoc_source

        # add a virtual 'index.adoc' node as the only node in a source tree
        # with this object as source for conversion options
        # and adoc_source
        v_path = Pathname.new("/virtual") / index_dir / "index.adoc"
        v_tree = PathTree.new(v_path, self)
        src_node = v_tree.node(v_path, from_root: true)

        # add the destination node where the converted file will be stored
        i_node = dst_node.add_descendants("index")
        
        # do the conversion
        converter.convert(src_node, i_node, dst_tree)
      end
    end
  end
end
